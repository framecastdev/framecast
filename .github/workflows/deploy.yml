name: Deploy

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
          - staging
          - prod
  push:
    branches:
      - main
    paths:
      - 'crates/**'
      - 'infra/opentofu/**'
      - 'Cargo.toml'
      - 'Cargo.lock'

permissions:
  contents: read
  packages: read
  id-token: write  # Required for OIDC authentication with AWS

env:
  CARGO_TERM_COLOR: always
  RUST_BACKTRACE: 1
  RUSTUP_HOME: /opt/rust/rustup
  CARGO_HOME: /opt/rust/cargo

jobs:
  # Determine which environment to deploy to
  determine-environment:
    name: Determine Environment
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.set-env.outputs.environment }}
    steps:
      - name: Set environment
        id: set-env
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "environment=${{ github.event.inputs.environment }}" >> $GITHUB_OUTPUT
          else
            # Auto-deploy to dev on push to main
            echo "environment=dev" >> $GITHUB_OUTPUT
          fi

  build:
    name: Build Lambda
    runs-on: self-hosted
    needs: [determine-environment]
    container:
      image: ghcr.io/framecastdev/framecast-ci:latest
      credentials:
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
    outputs:
      lambda-artifact: ${{ steps.upload.outputs.artifact-id }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Cache Rust dependencies
        uses: Swatinem/rust-cache@v2
        with:
          shared-key: "deploy"

      - name: Build Lambda with cargo-lambda
        run: just lambda-build

      - name: Upload Lambda artifact
        id: upload
        uses: actions/upload-artifact@v4
        with:
          name: lambda-${{ github.sha }}
          path: target/lambda/lambda/bootstrap.zip
          retention-days: 7

  deploy:
    name: Deploy to ${{ needs.determine-environment.outputs.environment }}
    runs-on: self-hosted
    needs: [determine-environment, build]
    environment: ${{ needs.determine-environment.outputs.environment }}
    container:
      image: ghcr.io/framecastdev/framecast-ci:latest
      credentials:
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
    env:
      ENVIRONMENT: ${{ needs.determine-environment.outputs.environment }}
      # OpenTofu variables from GitHub secrets
      TF_VAR_database_url: ${{ secrets.DATABASE_URL }}
      TF_VAR_jwt_secret: ${{ secrets.JWT_SECRET }}
      TF_VAR_supabase_url: ${{ secrets.SUPABASE_URL }}
      TF_VAR_supabase_anon_key: ${{ secrets.SUPABASE_ANON_KEY }}
      TF_VAR_anthropic_api_key: ${{ secrets.ANTHROPIC_API_KEY }}
      TF_VAR_inngest_event_key: ${{ secrets.INNGEST_EVENT_KEY }}
      TF_VAR_inngest_signing_key: ${{ secrets.INNGEST_SIGNING_KEY }}
      TF_VAR_runpod_api_key: ${{ secrets.RUNPOD_API_KEY }}
      TF_VAR_runpod_endpoint_id: ${{ secrets.RUNPOD_ENDPOINT_ID }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Download Lambda artifact
        uses: actions/download-artifact@v4
        with:
          name: lambda-${{ github.sha }}
          path: target/lambda/lambda/

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_DEPLOY_ROLE_ARN }}
          aws-region: us-east-1

      - name: Initialize OpenTofu
        run: |
          cd infra/opentofu
          tofu init -input=false

      - name: Plan infrastructure changes
        run: |
          cd infra/opentofu
          tofu plan -var-file=environments/${{ env.ENVIRONMENT }}.tfvars -out=tfplan -input=false

      - name: Apply infrastructure changes
        run: |
          cd infra/opentofu
          tofu apply -input=false tfplan

      - name: Get deployment outputs
        id: outputs
        run: |
          cd infra/opentofu
          echo "api_endpoint=$(tofu output -raw api_endpoint)" >> $GITHUB_OUTPUT
          echo "lambda_function_name=$(tofu output -raw lambda_function_name)" >> $GITHUB_OUTPUT

      - name: Deployment summary
        run: |
          echo "## Deployment Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Environment:** ${{ env.ENVIRONMENT }}" >> $GITHUB_STEP_SUMMARY
          echo "**API Endpoint:** ${{ steps.outputs.outputs.api_endpoint }}" >> $GITHUB_STEP_SUMMARY
          echo "**Lambda Function:** ${{ steps.outputs.outputs.lambda_function_name }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Commit:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY

  # Smoke test after deployment
  smoke-test:
    name: Smoke Test
    runs-on: self-hosted
    needs: [determine-environment, deploy]
    container:
      image: ghcr.io/framecastdev/framecast-ci:latest
      credentials:
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Get API endpoint
        id: get-endpoint
        run: |
          cd infra/opentofu
          tofu init -input=false
          echo "api_endpoint=$(tofu output -raw api_endpoint)" >> $GITHUB_OUTPUT
        env:
          TF_VAR_database_url: "dummy"
          TF_VAR_jwt_secret: "dummy"

      - name: Health check
        run: |
          ENDPOINT="${{ steps.get-endpoint.outputs.api_endpoint }}"
          echo "Testing health endpoint: ${ENDPOINT}/health"

          # Retry up to 5 times with 10 second delay
          for i in {1..5}; do
            if curl -sf "${ENDPOINT}/health" >/dev/null; then
              echo "Health check passed!"
              exit 0
            fi
            echo "Attempt $i failed, retrying in 10 seconds..."
            sleep 10
          done

          echo "Health check failed after 5 attempts"
          exit 1

      - name: Test version endpoint
        run: |
          ENDPOINT="${{ steps.get-endpoint.outputs.api_endpoint }}"
          echo "Testing version endpoint: ${ENDPOINT}/version"
          curl -sf "${ENDPOINT}/version" | jq '.'

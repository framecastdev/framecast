--- domains/jobs/src/domain/state.rs
+++ replace JobStateMachine::transition -> Result<JobState, StateError> with Ok(Default::default())
@@ -98,41 +98,17 @@
 pub struct JobStateMachine;

 impl JobStateMachine {
     /// Attempt a state transition
     ///
     /// Returns the new state if the transition is valid, or an error otherwise.
     pub fn transition(current: JobState, event: JobEvent) -> Result<JobState, StateError> {
         // Check for terminal state
-        if current.is_terminal() {
-            return Err(StateError::TerminalState(current.to_string()));
-        }
-
-        let next = match (&current, &event) {
-            // From Queued
-            (JobState::Queued, JobEvent::WorkerPicksUp) => JobState::Processing,
-            (JobState::Queued, JobEvent::Cancel) => JobState::Canceled,
-
-            // From Processing
-            (JobState::Processing, JobEvent::Success) => JobState::Completed,
-            (JobState::Processing, JobEvent::Failure) => JobState::Failed,
-            (JobState::Processing, JobEvent::Cancel) => JobState::Canceled,
-
-            // Invalid transitions
-            _ => {
-                return Err(StateError::InvalidTransition {
-                    from: current.to_string(),
-                    to: "unknown".to_string(),
-                    event: event.to_string(),
-                });
-            }
-        };
-
-        Ok(next)
+        Ok(Default::default()) /* ~ changed by cargo-mutants ~ */
     }

     /// Check if a transition is valid without performing it
     pub fn can_transition(current: JobState, event: &JobEvent) -> bool {
         Self::transition(current, event.clone()).is_ok()
     }
 }
